# Cursor Rules for Product Careerlyst

## For data migrations or investigations 
Always just use the Supabase MCP when doing data investigations or running migrations. 

## Amplitude Event Tracking Standards

### Event Naming Convention
- **Format**: `User [Action] [Object]` in Title Case
- **Examples**: 
  - ✅ `User Clicked Sign Up Button`
  - ✅ `User Viewed Homepage`
  - ✅ `User Expanded Course`
  - ❌ `clicked signup` (wrong case)
  - ❌ `Page Viewed` (too generic, missing "User")
  - ❌ `Sign Up Clicked` (wrong order)

### Required Properties for Click Events

When tracking button/link clicks, ALWAYS include:

1. **Unique Identifier** (REQUIRED):
   - `buttonId` or `linkId` prop: Unique identifier like `homepage-hero-primary-cta`
   - Format: `[page]-[section]-[element-type]-[descriptor]`
   - Example: `courses-page-bottom-cta`, `homepage-features-pm-courses-link`

2. **Location Context** (REQUIRED):
   - `Button Section` or `Link Section`: Exact section name (e.g., "Hero Section", "Features Section")
   - `Button Position` or `Link Position`: Exact position (e.g., "Center of Hero Card", "Bottom of page")
   - `Button Context` or `Link Context`: What's around it (e.g., "Below headline and outcome highlights")
   - `Page Section`: Above/below fold indicator

3. **Content Context** (REQUIRED):
   - `Button Text` or `Link Text`: The visible text on the element
   - `Button Type` or `Link Type`: Type classification (e.g., "Primary CTA", "Feature Card CTA")

4. **Source Tracking** (AUTOMATIC):
   - Referrer URL/Domain (automatically captured)
   - UTM parameters (automatically captured)
   - Click coordinates (automatically captured)

### Using TrackedButton Component

```tsx
<TrackedButton
  href="/auth/sign-up"
  buttonId="homepage-hero-primary-cta"  // REQUIRED: Unique ID
  eventName="User Clicked Sign Up Button"
  eventProperties={{
    'Button Section': 'Hero Section',           // REQUIRED
    'Button Position': 'Center of Hero Card',   // REQUIRED
    'Button Text': 'Start now for free →',      // REQUIRED
    'Button Type': 'Primary CTA',               // REQUIRED
    'Button Context': 'Below headline...',      // REQUIRED
    'Page Section': 'Above the fold',           // REQUIRED
  }}
>
  Start now for free →
</TrackedButton>
```

### Using TrackedLink Component

```tsx
<TrackedLink
  href="/courses"
  linkId="homepage-features-pm-courses-link"  // REQUIRED: Unique ID
  eventName="User Clicked Courses Link"
  eventProperties={{
    'Link Section': 'Features Section',        // REQUIRED
    'Link Position': 'PM Courses Feature Card', // REQUIRED
    'Link Text': 'Browse Courses →',           // REQUIRED
    'Link Type': 'Feature Card CTA',          // REQUIRED
    'Feature Card': 'PM Courses',              // Context-specific
    'Card Position': 'First Feature Card',     // Context-specific
  }}
>
  Browse Courses →
</TrackedLink>
```

### Page View Events

For page views, use `PageTracking` component:

```tsx
<PageTracking pageName="Sign Up" />
```

This automatically includes:
- Page Route
- Page Name
- Full referrer information
- UTM parameters
- Traffic source categorization

### Custom Event Tracking

When using `trackEvent` directly, ALWAYS include:

```tsx
trackEvent('User [Action] [Object]', {
  'Page Route': window.location.pathname,
  'Referrer URL': document.referrer || 'None',
  'Referrer Domain': referrerDomain || 'None',
  'UTM Source': urlParams?.get('utm_source') || null,
  // ... event-specific properties
});
```

### Button ID Naming Convention

Format: `[page]-[section]-[element-type]-[descriptor]`

Examples:
- `homepage-hero-primary-cta`
- `homepage-final-cta-large-button`
- `courses-page-bottom-cta`
- `dashboard-resume-export-button`

### Link ID Naming Convention

Format: `[page]-[section]-[context]-link`

Examples:
- `homepage-features-pm-courses-link`
- `homepage-navigation-courses-link`
- `courses-page-header-signup-link`

### Event Properties Best Practices

1. **Always be specific**: "Hero Section" not "Top"
2. **Include context**: What's around the element
3. **Use descriptive names**: "Primary CTA" not "Button 1"
4. **Include text content**: The actual button/link text
5. **Specify position**: "Center of Hero Card" not just "Hero"
6. **Indicate page section**: "Above the fold" vs "Below the fold"

### Common Mistakes to Avoid

❌ **Don't**: Generic event names like "Button Clicked"
✅ **Do**: Specific names like "User Clicked Sign Up Button"

❌ **Don't**: Missing buttonId/linkId
✅ **Do**: Always include unique identifier

❌ **Don't**: Vague properties like "Top" or "Button"
✅ **Do**: Specific like "Hero Section, Center of Card"

❌ **Don't**: Missing referrer/UTM tracking
✅ **Do**: Always include source information (automatic in components)

❌ **Don't**: Inconsistent naming
✅ **Do**: Follow Title Case, "User [Action] [Object]" pattern

### Non-Blocking Tracking (CRITICAL)

**Analytics tracking must NEVER block user interactions or navigation.**

#### Core Principles

1. **All tracking is fire-and-forget**: Never await tracking calls
2. **Tracking never blocks navigation**: Links and buttons must respond immediately
3. **Errors are silent**: Analytics failures should never affect user experience
4. **Use setTimeout for click handlers**: Wrap tracking logic in `setTimeout(..., 0)` to defer execution

#### Implementation Rules

**✅ DO:**
- Use `trackEvent()` synchronously (it's already non-blocking internally)
- Wrap click tracking in `setTimeout(..., 0)` to defer execution
- Call `onClick()` callbacks immediately, before tracking
- Handle URL parsing errors with try-catch
- Let navigation happen immediately, tracking runs in background

**❌ DON'T:**
- Never `await trackEvent()` or `await identifyUser()`
- Never do synchronous work before navigation in click handlers
- Never let tracking errors throw or block execution
- Never wait for tracking to complete before navigation

#### Example: Non-Blocking Click Handler

```tsx
const handleClick = (e: React.MouseEvent) => {
  // ✅ Call onClick immediately - don't wait for tracking
  if (onClick) {
    onClick();
  }
  
  // ✅ Defer tracking to next event loop tick
  setTimeout(() => {
    try {
      // All tracking logic here
      trackEvent(eventName, eventProperties);
    } catch (error) {
      // Silently fail - analytics should never block
      if (process.env.NODE_ENV === 'development') {
        console.warn('⚠️ Tracking error (non-blocking):', error);
      }
    }
  }, 0);
};
```

#### How trackEvent Works

- `trackEvent()` is **synchronous** (returns immediately)
- **Single-sending strategy**: Uses Browser SDK if initialized, otherwise falls back to API route
- **NEVER send both**: Each event is sent exactly once (Browser SDK OR API route, never both)
- Browser SDK tracking happens synchronously (if available)
- API route tracking uses `Promise.race()` with 50ms timeout for `getUser()`
- All fetch requests are fire-and-forget (no await)
- Errors are handled silently (warnings only in dev mode)

#### Single-Sending Strategy (CRITICAL)

**Each event must be sent exactly ONCE, not twice.**

**✅ CORRECT:**
- Use `trackEvent()` from `@/lib/amplitude/client` - it handles single-sending automatically
- Browser SDK is preferred when initialized (enables Session Replay)
- API route is used as fallback when Browser SDK is not available
- The client library checks `isBrowserSdkInitialized()` to decide which method to use

**❌ NEVER DO:**
- Never call both `trackEventBrowser()` AND `trackEvent()` for the same event
- Never call both Browser SDK and API route directly
- Never send events via multiple methods simultaneously
- Never bypass the client library's single-sending logic

**Decision Logic:**
```typescript
// ✅ CORRECT - Use client library (handles single-sending)
import { trackEvent } from '@/lib/amplitude/client';
trackEvent('User Clicked Button', { ... });

// ❌ WRONG - Don't call both methods
trackEventBrowser('User Clicked Button', { ... });  // Browser SDK
trackEvent('User Clicked Button', { ... });         // Also sends to API route = DOUBLE SEND!

// ❌ WRONG - Don't bypass client library
import { trackEventBrowser } from '@/lib/amplitude/browser';
import { trackEvent } from '@/lib/amplitude/client';
// Calling both = DOUBLE SEND!
```

**For API Routes:**
- API routes use server-side SDK (`@/lib/amplitude/server`)
- **CRITICAL**: Never `await` tracking calls in API routes - always fire-and-forget
- Server-side tracking is separate from client-side tracking
- Example:
  ```typescript
  // ✅ CORRECT - Fire-and-forget
  trackEvent(eventType, eventProperties, userId, deviceId).catch((error) => {
    // Handle errors silently
  });
  return NextResponse.json({ success: true }); // Return immediately

  // ❌ WRONG - Blocks API response
  await trackEvent(eventType, eventProperties, userId, deviceId);
  return NextResponse.json({ success: true }); // Waits 30+ seconds!
  ```

#### Components Already Non-Blocking

- ✅ `TrackedLink` - Uses setTimeout to defer tracking
- ✅ `TrackedButton` - Uses setTimeout to defer tracking
- ✅ `PageTracking` - Tracking happens in useEffect (non-blocking)
- ✅ `NavLink` - Tracking happens before navigation
- ✅ All form components - Tracking happens after user actions

### When Adding New Tracking

1. **Identify the exact location**: Section, position, context
2. **Create unique ID**: Follow naming convention
3. **Use TrackedButton/TrackedLink**: Don't use raw trackEvent for clicks
4. **Include all required properties**: Section, Position, Text, Type, Context
5. **Ensure non-blocking**: Use setTimeout for click handlers
6. **Use client library only**: Always import from `@/lib/amplitude/client`, never call Browser SDK directly
7. **Verify single-sending**: Check Amplitude dashboard to ensure events aren't duplicated
8. **Test**: Verify event fires with all properties AND navigation is instant

### Reference Files

- `AMPLITUDE_EVENTS_DETAILED.md` - Complete list of all events
- `app/components/TrackedButton.tsx` - Button component implementation
- `app/components/TrackedLink.tsx` - Link component implementation
- `lib/amplitude/client.ts` - Client-side tracking utilities

---

## Email Flow Implementation (Inngest + Resend + Supabase)

When creating email sequences/flows, follow these critical rules:

### Critical Learnings (MUST FOLLOW)

#### 1. Fire-and-Forget DOES NOT Work in Serverless
Async fire-and-forget patterns fail silently in serverless environments (Vercel, Next.js API routes). When the HTTP response returns, the serverless function can terminate before background async work completes.

**Solution:** Use Inngest steps to ensure critical async work runs to completion in a durable context.

#### 2. Inngest Steps Are Your Durability Boundary
Each `step.run()` is:
- Checkpointed (can resume if interrupted)
- Retried on failure
- Guaranteed to complete before the function reports success

**Required Pattern for ALL Inngest functions:**
```typescript
// Step N: Database operation (fast, returns immediately)
const records = await step.run('db-operation', async () => { ... });

// Step N+1: External API calls (slow, needs durability)
await step.run('process-external-api', async () => {
  // CRITICAL: Wait for any fire-and-forget to settle
  await new Promise(resolve => setTimeout(resolve, 2000));
  // Re-fetch from DB to get actual current state
  // Process only what still needs processing
});
```

#### 3. Race Conditions Between Steps
The scheduling step returns stale data (status: 'pending') but fire-and-forget may have already updated some records to 'scheduled'. The Resend processing step MUST:
- Add 2-second delay to let fire-and-forget settle
- Re-fetch from DB to get actual current status
- Only process records that still need processing

#### 4. Resend Rate Limiting (2 req/sec)
Resend has a 2 requests/second limit. Use 600ms delay between calls (~1.67 req/sec) as a safe margin. This applies to BOTH scheduling AND cancellation.

#### 5. Idempotency is Critical
- Use `flow_trigger_id` to prevent duplicate sequences
- Use Inngest event `id` for idempotency keys
- Check DB for existing records before scheduling

#### 6. Environment-Based Test Mode
Auto-detect `NODE_ENV === 'development'` to use test timing (1 minute = 1 day) in the Inngest function itself:
```typescript
const isTestMode = process.env.NODE_ENV === 'development';
const testModeMultiplier = isTestMode ? 1 / 1440 : 1;
```

#### 7. Never Hardcode Fallback Names
Email components should handle null firstName with `"Hey there,"` - NEVER use fallbacks like `'Test User'` or `'there'` in service code. Always pass `null`.

### Implementation Checklist

1. **Create Email Template Components** - `app/components/emails/YourFlowEmail.tsx`
   - Handle `firstName?: string | null` with proper fallback: `firstName ? \`Hey ${firstName},\` : 'Hey there,'`
   - Include unsubscribe link for marketing emails

2. **Register Components** - `lib/email/templates.ts`
   - Add import and register in `COMPONENT_REGISTRY`

3. **Add Inngest Event Types** - `lib/inngest/client.ts`
   - Add `'your-flow/started'` and `'your-flow/completed'` events

4. **Create Inngest Functions** - `lib/inngest/functions/your-flow-emails.ts`
   - `triggerYourFlowSequence` with steps:
     1. Get flow from DB
     2. Check for existing emails (idempotency)
     3. Get user profile for firstName
     4. Schedule sequence (DB insert)
     5. Process Resend scheduling (CRITICAL - with 2s delay and re-fetch)
   - `cancelYourFlowSequence` with steps:
     1. Get flow from DB
     2. Cancel in DB (returns emails)
     3. Process Resend cancellation (CRITICAL - with 2s delay)

5. **Register Functions** - `app/api/inngest/route.ts`

6. **Database Migration** - Create templates, flow, and flow_steps in Supabase

7. **Trigger Events** - Add `inngest.send()` calls where appropriate

### Email Flow Reference Files

- `lib/inngest/functions/onboarding-abandoned-emails.ts` - Working trigger/cancel example
- `lib/inngest/functions/trial-emails.ts` - Working trigger/cancel example
- `lib/email/service.ts` - Core email scheduling functions (scheduleSequence, processResendSchedulingForEmails, processResendCancellationForEmails)
- `lib/email/templates.ts` - Template registry and COMPONENT_REGISTRY
- `lib/email/flows.ts` - Flow utilities (getAllFlows, generateFlowTriggerId)
- `app/components/emails/OnboardingAbandoned15MinEmail.tsx` - Email component example
- `.claude/commands/create-email-flow.md` - Full implementation guide with code templates

